# Garbage Collection

### JVM 의 Heap 영역의 전제조건

- 대부분의 객체는 금방 접근 불가능 상태가 된다. (unreachable)
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

즉 , 객체는 대부분 일회성이며 메모리에 오랫동안 남아있는 경우는 드물다. 그렇기 때문에 객체의 생존 기간에 따라 물리적인 Heap 영역으로 나누게 되었고 Young, Old 총 2가지 영역으로 설계되었다.

### Young 영역 (young generation)

- 새롭게 생성된 객체가 할당되는 영역
- 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 young 영역에 생성되었다가 사라진다.
- young 영역에 대한 가비지 컬렉션을 Minor GC 라고 부른다.
- Eden 과 Survivor 영역(2개) 으로 나눈다.

### Old 영역 (Old Generation)

- young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
- young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생한다.
- Old 영역에 대한 가비지 컬레션을 Majog GC 또는 Full GC 라고 부른다.

Eden 에는 처음 생성된 객체가 위치하게 된다. 그러다 Eden 영역이 꽉차면 Minor GC 가 발생하게 되면, 이 영역에 위치하는 객체 중 참조되지 않는 객체는 메모리에서 제거되며, 살아남은 객체들은 Survivor 영역 두 군데 중 한 군데로 이동하게 된다. Minor GC 가 발동될 때마다, Survivor 영역에 있던 객체들은 다른 Survivor 영역으로 이동한다.

각 객체는 Minor GC 에서 살아남은 횟수를 기록하는 age bit 를 가지고 있으며, 이 age bit 는 Minor GC가 발생할 때마다 하나씩 증가한다. age bit 값이 MaxTenuringThreshold 라는 설정값을 초과하게 되는 경우, Old Generation 영역으로 객체가 이동하게 된다.

보통 young 영역에는 작은 객체들이 들어가며, 큰 객체들은 Old 에 할당된다. 예외적으로 Old 영역에서 Young 영역의 객체를 참조하는 경우도 존재한다. 이러한 경우를 대비하여 Old 영역에는 512bytes의 덩어리(chunk)로 되어 있는 카드 테이블(card table)이 존재한다.

카드 테이블에는 Old 영역에 있는 객체가 young 영역의 객체를 참조할 때 마다 그에 대한 정보가 표시된다. 카드 테이블이 도입된 이유는 다음과 같다. Young 영역에서 가비지 컬렉션이 실행될 때 모든 Old 영역에 존재하는 객체를 검사하여 참조되지 않는 Young 영역의 객체를 식별하는 것이 비효율적이기 때문이다. 그렇기 때문에 young 영역에서 가바지 컬렉션이 진행될 때 카드 테이블만 조회하여 GC의 대상인지 식별할 수 있도록 한다.

### GC 알고리즘

GC 알고리즘의 기본 흐름은 GC 대상을 식별하고, 식별된 대상을 메모리에 제거하며, 필요한 경우 최적화까지 수행한다.

- Serial GC

  이 알고리즘의 첫 단계는 Old 영역에 살아있는 객체를 식별(Mark) 하는 것이다. 그 다음에는 힙의 앞 부분부터 확인하여 살아 있느 것만 남긴다.(Sweep) 마지막 단계에서는 객체가 존재하는 부분과 존재하지 않는 부분으로 나눈다.(Compaction)

- Parallel GC

  Serial GC 로 GC 처리를 할 경우 병목현상이 발생할 수 있어 속도의 저하가 예상된다. 다중 쓰레드에서 실행 될 수 있는 GC 구조이다.